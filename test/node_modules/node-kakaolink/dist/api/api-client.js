"use strict";
/**
 * Created by archethic on 2021/08/06
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _ApiClient_cookieJar, _ApiClient_loginRes, _ApiClient_apiKey, _ApiClient_url;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoginStatusCode = exports.ApiClient = void 0;
const axios_1 = __importDefault(require("axios"));
const axios_cookiejar_support_1 = __importDefault(require("axios-cookiejar-support"));
const cheerio_1 = require("cheerio");
const tough_cookie_1 = require("tough-cookie");
const config_1 = require("../config");
const crypto_js_1 = __importDefault(require("crypto-js"));
(0, axios_cookiejar_support_1.default)(axios_1.default);
class ApiClient {
    constructor(cookie, loginRes, apiKey, url) {
        _ApiClient_cookieJar.set(this, void 0);
        _ApiClient_loginRes.set(this, void 0);
        _ApiClient_apiKey.set(this, void 0);
        _ApiClient_url.set(this, void 0);
        __classPrivateFieldSet(this, _ApiClient_cookieJar, cookie, "f");
        if (loginRes === undefined)
            throw new Error(`crypto key is not defined`);
        __classPrivateFieldSet(this, _ApiClient_loginRes, loginRes, "f");
        __classPrivateFieldSet(this, _ApiClient_apiKey, apiKey, "f");
        __classPrivateFieldSet(this, _ApiClient_url, url, "f");
    }
    static async create(apiKey, url) {
        const cookieJar = new tough_cookie_1.CookieJar();
        const getLoginRes = await (0, axios_1.default)({
            method: 'GET',
            url: config_1.LinkConfig.accountsUrl,
            headers: {
                Referer: 'https://accounts.kakao.com/'
            },
            jar: cookieJar,
            withCredentials: true,
        });
        if (getLoginRes.status !== 200) {
            throw new Error(`Kakao Accounts Load Failed with status: ${getLoginRes.status}`);
        }
        await (0, axios_1.default)({
            method: 'get',
            url: config_1.LinkConfig.getTiaraUrl,
            jar: cookieJar,
            withCredentials: true
        });
        const $ = (0, cheerio_1.load)(getLoginRes.data);
        return new ApiClient(cookieJar, $, apiKey, url);
    }
    async login(loginParams) {
        const cryptoKey = __classPrivateFieldGet(this, _ApiClient_loginRes, "f").call(this, 'input[name=p]').attr('value').toString();
        const csrfToken = __classPrivateFieldGet(this, _ApiClient_loginRes, "f").call(this, 'head > meta:nth-child(3)').attr('content').toString();
        const getAuthRes = await (0, axios_1.default)({
            method: 'POST',
            url: config_1.LinkConfig.getAuthUrl,
            headers: {
                Referer: config_1.LinkConfig.accountsUrl,
            },
            data: {
                os: 'web',
                webview_v: '2',
                email: crypto_js_1.default.AES.encrypt(loginParams.email, cryptoKey).toString(),
                password: crypto_js_1.default.AES.encrypt(loginParams.password, cryptoKey).toString(),
                stay_signed_in: String(loginParams.keeplogin) || 'true',
                continue: decodeURIComponent(config_1.LinkConfig.accountsUrl.split('=')[1]),
                third: 'false',
                k: 'true',
                authenticty_token: csrfToken
            },
            jar: __classPrivateFieldGet(this, _ApiClient_cookieJar, "f"),
            withCredentials: true,
            responseType: 'json'
        });
        if (getAuthRes.data['status'] != 0) {
            return {
                success: false,
                status: getAuthRes.data.status,
                message: getAuthRes.data.message
            };
        }
        return {
            success: true,
            status: getAuthRes.data.status,
            result: {
                apiKey: __classPrivateFieldGet(this, _ApiClient_apiKey, "f"),
                url: __classPrivateFieldGet(this, _ApiClient_url, "f"),
                cookieJar: __classPrivateFieldGet(this, _ApiClient_cookieJar, "f")
            }
        };
    }
}
exports.ApiClient = ApiClient;
_ApiClient_cookieJar = new WeakMap(), _ApiClient_loginRes = new WeakMap(), _ApiClient_apiKey = new WeakMap(), _ApiClient_url = new WeakMap();
var LoginStatusCode;
(function (LoginStatusCode) {
    LoginStatusCode[LoginStatusCode["SUCCESS"] = 0] = "SUCCESS";
    LoginStatusCode[LoginStatusCode["CRYPTO_ERROR"] = -484] = "CRYPTO_ERROR";
    LoginStatusCode[LoginStatusCode["BLOCK_COUNTRY"] = -435] = "BLOCK_COUNTRY";
    LoginStatusCode[LoginStatusCode["INCORRECT_ACCOUNTS"] = -450] = "INCORRECT_ACCOUNTS";
    LoginStatusCode[LoginStatusCode["CAPCHA_BLOCK"] = -481] = "CAPCHA_BLOCK";
})(LoginStatusCode = exports.LoginStatusCode || (exports.LoginStatusCode = {}));
