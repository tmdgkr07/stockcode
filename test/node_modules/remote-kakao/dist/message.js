"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
class Message {
    socket;
    sessionEmitter;
    kakaoLink;
    remoteInfo;
    room;
    content;
    sender;
    isGroupChat;
    getProfileImage;
    constructor(data, sessionEmitter, socket, remoteInfo, kakaoLink) {
        this.socket = socket;
        this.sessionEmitter = sessionEmitter;
        this.remoteInfo = remoteInfo;
        this.room = data.room;
        this.content = data.content;
        this.sender = data.sender;
        this.isGroupChat = data.isGroupChat;
        this.getProfileImage = () => data.profileImage;
        this.kakaoLink = kakaoLink;
    }
    async replyText(text, room = this.room, address = this.remoteInfo.address, port = this.remoteInfo.port, timeout = 60) {
        return new Promise((res, rej) => {
            const session = (0, crypto_1.randomUUID)();
            const data = encodeURIComponent(JSON.stringify({ event: 'sendText', data: { room, text }, session }));
            const handler = (success, data) => {
                if (!success)
                    rej();
                else
                    res(data === undefined ? { success } : { success, data });
                this.sessionEmitter.off(session, handler);
            };
            this.sessionEmitter.on(session, handler);
            this.socket.send(data, 0, data.length, port, address);
            setTimeout(() => rej(), 1000 * timeout);
        });
    }
    async replyKakaoLink(template, room = this.room) {
        return new Promise((res, rej) => {
            if (!this.kakaoLink)
                return rej('카카오링크 사용이 설정되지 않았습니다.');
            this.kakaoLink
                .sendLink(room, { link_ver: '4.0', template_id: template.id, template_args: template.args ?? {} }, 'custom')
                .then(res)
                .catch(rej);
        });
    }
}
exports.default = Message;
