"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dgram_1 = require("dgram");
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const node_kakaolink_1 = require("node-kakaolink");
const message_1 = __importDefault(require("./message"));
class Server extends eventemitter3_1.default {
    socket = (0, dgram_1.createSocket)('udp4');
    port = 3000;
    sessionEmitter;
    kakaoLink;
    constructor(config = { useKakaoLink: false }) {
        super();
        if (config.useKakaoLink)
            this.kakaoLink = new node_kakaolink_1.KakaoLinkClient();
        this.sessionEmitter = new eventemitter3_1.default();
    }
    async start(port = 3000, kakaoLinkConfig) {
        this.port = port;
        this.socket.bind(this.port);
        if (this.kakaoLink && kakaoLinkConfig) {
            const api = await node_kakaolink_1.ApiClient.create(kakaoLinkConfig.key, kakaoLinkConfig.host);
            const loginRes = await api.login({
                email: kakaoLinkConfig.email,
                password: kakaoLinkConfig.password,
                keeplogin: true,
            });
            if (!loginRes.success)
                throw new Error('카카오링크 로그인을 실패했습니다!');
            this.kakaoLink.login(loginRes.result);
        }
        this.socket.on('message', (msg, remoteInfo) => {
            const { event, session, success, data } = JSON.parse(msg.toString());
            if (event && !session)
                switch (event) {
                    case 'chat':
                        const message = new message_1.default(data, this.sessionEmitter, this.socket, remoteInfo, this.kakaoLink);
                        this.emit('message', message);
                        break;
                }
            else
                this.sessionEmitter.emit(session, success, data);
        });
    }
}
exports.default = Server;
